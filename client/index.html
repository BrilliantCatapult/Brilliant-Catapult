<!DOCTYPE html>
<html>

<head>
  <title></title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="d3.geo.til.js"></script>
  <script src="dockRoutes/dockRoutesObj.js"></script>
  <script src="buildgeojson.js"></script>
  <meta charset="utf-8">
  <style>
  body {
    margin: 0;
  }
  
  .map {
    position: relative;
    overflow: hidden;
  }
  
  .layer {
    position: absolute;
  }
  
  .tile {
    position: absolute;
    width: 256px;
    height: 256px;
  }
  
  .tile path {
    fill: none;
    stroke: grey;
    stroke-linejoin: round;
    stroke-linecap: round;
  }
  
  .tile .major_road {
    stroke: #776;
  }
  
  .tile .minor_road {
    stroke: #ccb;
  }
  
  .tile .highway {
    stroke: #f39;
    stroke-width: 1.5px;
  }
  
  .tile .rail {
    stroke: #7de;
  }
  
  .info {
    position: absolute;
    bottom: 10px;
    left: 10px;
  }
  
  .svg-paths {
    background-color: transparent;
    position: absolute;
  }
  </style>
  </head>

  <body>
    <div id="buttons">
      <button id="playbutton">Play</button>
    </div>
    <div id="slider"></div>
    
    <script>
    var width = window.innerWidth - 50;
    var height = Math.max(500, window.innerHeight);
    var prefix = prefixMatch(["webkit", "ms", "Moz", "O"]);

    var second = 1000;
    var minute = 60 * second;
    var hour = 60 * minute;
    var day = 24 * hour;

    var dbJson;
    var play = false;
    var realTimeFormat;
    var timer, timermemo = 0;
    var realtime;
    var circles = [];

    var animduration = 5 * minute;

    var formatMilliseconds = function(d) {
      var hours = Math.floor(d / hour);
      var minutes = Math.floor((d % hour) / minute);
      if (minutes < 10) {
        minutes = "0" + minutes;
      }
      return hours + ":" + minutes;
    };

    var timeToMilliSeconds = function(string) {
      var values = string.split(":");
      return values[0] * hour + values[1] * minute;
    };

    var timescale = d3.time.scale()
      .domain([new Date, new Date])
      .nice(d3.time.day)
      .range([0, width]);

    var animscale = d3.scale.linear()
      .domain([0, animduration])
      .range([0, width]);

    var axis = d3.svg.axis()
      .scale(timescale)
      .ticks(24)
      .tickFormat(d3.time.format("%H"));

    var tile = d3.geo.tile()
      .size([width, height]);

    var projection = d3.geo.mercator()
      .scale((1 << 21) / 2 / Math.PI)
      .translate([-width / 2, -height / 2]);

    var path = d3.geo.path()
      .projection(projection);

    var tilePath = d3.geo.path()
      .projection(projection);

    var zoom = d3.behavior.zoom()
      .scale(projection.scale() * 2 * Math.PI)
      .scaleExtent([1 << 20, 1 << 23])
      .translate(projection([-122.4, 37.7782]).map(function(x) {
        console.log('zoom', x);
        return -x;
      }))
      .on("zoom", render);

    var map = d3.select("body").append("div")
      .attr("class", "map")
      .style("width", width + "px")
      .style("height", height + "px")
      .call(zoom);
    // .on("mousemove", mousemoved);

    var tilesLayer = map.append("div")
      .attr("class", "layer");

    var info = map.append("div")
      .attr("class", "info");

    var svgTimeline = d3.select("body").append("svg")
      .attr("width", width);

    svgTimeline.append("g")
      .attr("transform", "translate(5,0)")
      .call(axis);

    var cursor = svgTimeline.append("circle")
      .attr('r', 8)
      .attr("fill", "red")
      .attr("id", "cursor");

    var svgBikeRoutes = map.append("svg:svg")
      .attr("class", 'points')
      .style("width", width + "px")
      .style("height", height + "px")
      .call(zoom);

    projection
      .scale(zoom.scale() / 2 / Math.PI)
      .translate(zoom.translate());

    d3.json("/api/timeline", function(error, json) {
      if (error) {
        console.log("error", error);
      }
      dbJson = parseDBJson(json);
      console.log("successsssss--------->", dbJson);
      drawTrip(dbJson);
    });

    var animate = function(e) {
      if (!play) {
        timermemo = timer;
        return true;
      }
      timer = (timermemo + e) % animduration;
      realtime = timer * day / animduration;
      realTimeFormat = formatMilliseconds(realtime);

      // console.log("timer", realTimeFormat, timer);

      cursor.attr("transform", function(d) {
        return "translate(" + animscale(timer) + ")";
      });

      for (var i = 0; i < circles[0].length; i++) {
        d3.select(circles[0][i]).attr("transform", function(d) {
          var thePath = d3.select(this.parentNode).select("path").node();
          var startTime = timeToMilliSeconds(d.properties.startTime);
          var endTime = timeToMilliSeconds(d.properties.endTime);

          if (realtime - startTime > 0 && endTime - realtime > 0) {
            var p = thePath.getPointAtLength(thePath.getTotalLength() * (realtime - startTime) / (endTime - startTime));
            return "translate(" + [p.x, p.y] + ")";
          }
        });
      }
    };

    var button = d3.select("#playbutton");
    button.on("click", function() {
      play = !play;
      if (play) {
        d3.timer(animate);
      }
    });

    var drawTrip = function(trips) {
      var routes = svgBikeRoutes.append("svg:g")
        .selectAll("path")
        .data(trips.features)
        .enter()
        .append("svg:g")
        .attr("class", "route")
        .append("svg:path")
        .attr("d", path)
        .attr("fill-opacity", 0)
        .attr("stroke", "#333");

      circles = svgBikeRoutes.selectAll(".route")
        .append("circle")
        .attr("r", 10)
        .attr("fill", '#f33');
    }

    d3.json("docks.json", function(error, dots) {
      if (error) throw error;
      console.log(dots);
      svgBikeRoutes.selectAll(".dock").data(dots)
        .enter()
        .append("circle")
        .attr("class", "dock")
        .attr("cx", function(d) {
          console.log(d, projection(d));
          return projection(d)[0];
        })
        .attr("cy", function(d) {
          return projection(d)[1];
        })
        .attr("r", "8px")
        .attr("fill", "red");

      render();
    });

    function render() {
      var tiles = tile
        .scale(zoom.scale())
        .translate(zoom.translate())
        ();

      projection
        .scale(zoom.scale() / 2 / Math.PI)
        .translate(zoom.translate());

      var image = tilesLayer
        .style(prefix + "transform", matrix3d(tiles.scale, tiles.translate))
        .selectAll(".tile")
        .data(tiles, function(d) {
          return d;
        });

      image.exit()
        .each(function(d) {
          this._xhr.abort();
        })
        .remove();

      image.enter().append("svg")
        .attr("class", "tile")
        .style("left", function(d) {
          return d[0] * 256 + "px";
        })
        .style("top", function(d) {
          return d[1] * 256 + "px";
        })
        .each(function(d) {
          var svgTile = d3.select(this);
          this._xhr = d3.json("http://" + ["a", "b", "c"][(d[0] * 31 + d[1]) % 3] + ".tile.openstreetmap.us/vectiles-highroad/" + d[2] + "/" + d[0] + "/" + d[1] + ".json", function(error, json) {
            var k = Math.pow(2, d[2]) * 256; // size of the world in pixels

            tilePath.projection()
              .translate([k / 2 - d[0] * 256, k / 2 - d[1] * 256]) // [0°,0°] in pixels
              .scale(k / 2 / Math.PI);

            svgTile.selectAll("path")
              .data(json.features.sort(function(a, b) {
                return a.properties.sort_key - b.properties.sort_key;
              }))
              .enter().append("path")
              .attr("class", function(d) {
                return d.properties.kind;
              })
              .attr("d", tilePath);
          });
        });

      svgBikeRoutes.selectAll(".dock")
        .attr("cx", function(d) {
          return projection(d)[0];
        })
        .attr("cy", function(d) {
          return projection(d)[1];
        });

      svgBikeRoutes.selectAll(".route path")
        .attr("d", path);

      svgBikeRoutes.selectAll(".route circle")
        .attr({
          "transform": function() {
            var thePath = d3.select(this.parentNode).select("path").node();
            var p = thePath.getPointAtLength(thePath.getTotalLength());
            return "translate(" + [p.x, p.y] + ")";
          }
        });
    }

    function mousemoved() {
      // info.text(formatLocation(projection.invert(d3.mouse(this)), zoom.scale()));
    }

    function matrix3d(scale, translate) {
      var k = scale / 256,
        r = scale % 1 ? Number : Math.round;
      return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1] + ")";
    }

    function prefixMatch(p) {
      var i = -1,
        n = p.length,
        s = document.body.style;
      while (++i < n)
        if (p[i] + "Transform" in s) return "-" + p[i].toLowerCase() + "-";
      return "";
    }

    function formatLocation(p, k) {
      var format = d3.format("." + Math.floor(Math.log(k) / 2 - 2) + "f");
      return (p[1] < 0 ? format(-p[1]) + "°S" : format(p[1]) + "°N") + " " + (p[0] < 0 ? format(-p[0]) + "°W" : format(p[0]) + "°E");
    }
    </script>
    <button class="button">click</button>
  </body>

</html>
